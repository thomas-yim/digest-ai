This document is copyright (C) Stanford Computer Science and Nick Troccoli, licensed under Creative Commons Attribution 2.5 License.  All rights reserved.Based on slides and notes created by John Ousterhout, Jerry Cain, Chris Gregg, and others. NOTICE RE UPLOADING TO WEBSITES:  This content is protected and may not be shared, uploaded, or distributed. (without expressed written permission)CS111, Lecture 7Crash Recovery
üò∑masks strongly recommendedTopic 1: Filesystems-How can we design filesystems to manage files on disk, and what are the tradeoffs inherent in designing them?  How can we interact with the filesystem in our programs?CS111 Topic 1: FilesystemsFilesystemsintroduction and designCase study: Unix V6 FilesystemFilesystem System calls and file descriptorsCrash recoveryLecture 1Lecture 2-4Lecture 5Lecture 6 / Todayassign2:implement a program that can repair a filesystem after a crash, andexplore some of the security and ethical implications of OSes / filesystems.Learning Goals‚Ä¢Gain exposure to 3 approaches to crash recovery: consistency checks on reboot, ordered writes and write-ahead logging‚Ä¢Compare and contrast different approaches to crash recovery‚Ä¢Understand the limitations and tradeoffs of crash recoveryPlan For Today‚Ä¢Recap and continuing: Free list and block cache‚Ä¢CrashRecoveryOverview‚Ä¢Approach #1: Consistency check on reboot (fsck)‚Ä¢Approach #2: Ordered Writes‚Ä¢Approach #3: Write-Ahead Logging (‚ÄúJournaling‚Äù)‚Ä¢assign2Plan For Today‚Ä¢Recap and continuing: Free list and block cache‚Ä¢Crash Recovery Overview‚Ä¢Approach #1: Consistency check on reboot (fsck)‚Ä¢Approach #2: Ordered Writes‚Ä¢Approach #3: Write-Ahead Logging (‚ÄúJournaling‚Äù)Crash RecoveryTo understand crash recovery, we need to understand all places where filesystem data is stored and maintained.‚Ä¢We know about most of the disk itself (e.g.Unix V6 layout)‚Ä¢Now we know that free blocks can be tracked using a bitmap.  This factors into crash recovery (e.g.free blocks not in a consistent state).‚Ä¢There is also the block cachein memory that stores frequently-used blocks accessed from disk.Block CacheProblem: Accessing disk blocks is expensive, especially if we do it repeatedly for the same blocks.Idea: use part of main memory to retain recently-accessed disk blocks. (Many OS-es do this).‚Ä¢A cache is a space to store and quickly access recently-/ frequently-used data.‚Ä¢Frequently-referenced blocks (e.g.indirect blocks for large files) usually in block cache.Challenge: cache size limited; how do we utilize it?  What if it gets full?Block CacheChallenge: cache size limited; how do we utilize it?  What if it gets full?One approach -least-recently-used ‚ÄúLRU‚Äù replacement‚ÄìIf we need something not in the cache, we read it from disk and then add it to the cache.  If there‚Äôs no room in the cache, we remove the least-recently-used element. Plan For Today‚Ä¢Recap and continuing: Free list and block cache‚Ä¢Crash Recovery Overview‚Ä¢Approach #1: Consistency check on reboot (fsck)‚Ä¢Approach #2: Ordered Writes‚Ä¢Approach #3: Write-Ahead Logging (‚ÄúJournaling‚Äù)Crash RecoverySometimes, computers crash or shut down unexpectedly.   In those situations, we want to avoid filesystem data loss or corruption as much as possible.How can we recover from crashes without losing file data or corrupting the disk?Crash RecoveryChallenge #1 ‚Äìdata loss:crashes can happen at any time, and not all data might have been saved to disk.‚Ä¢E.g.if you saved a file but it hadn‚Äôt actually beenwritten to disk yet.Challenge #2 -inconsistency:Crashes could happen even in the middle of operations, and this could leave the disk in an inconsistent state.‚Ä¢E.g.if a modification affects multiple blocks, a crash could occur when some of the blocks have been written to disk but not the others.‚Ä¢E.g.adding block to file: inode was written to store block number, but block wasn‚Äôt marked in the filesystem as used (it‚Äôs still listed in the free list)Ideally, filesystem operations would be atomic, meaning they happen in their entirety without interruption ‚Äìthey are never left in an incomplete state.  But this isn‚Äôt fully possible, since crashes can happen at any time.Crash RecoveryKey challenge: tradeoffs between crash recovery abilitiesand filesystem performance.Tradeoffs Example: the Block CacheThe block cache is a great example of how we may have to choose between crash recovery abilities and filesystem performance.Key question:what happens when a block in the cache is modified?  Do we stop and wait and immediately write it to disk?  Or do we delay it slightly until later?Block CacheKey Question:what happens when a block in the cache is modified?  Do we immediately write it to disk?  Pros/cons?If we immediately write to disk (‚Äúsynchronous writes‚Äù):‚Ä¢Safer: less risk (but not zero risk!) of data loss because it‚Äôs written as soon as possible.‚Ä¢Slow: program must wait to proceed until disk I/O completesBlock CacheKey Question:what happens when a block in the cache is modified?  Do we immediately write it to disk?  Pros/cons?If we don‚Äôt immediately write to disk (‚Äúdelayed writes‚Äù):‚Ä¢Wait a while (Unix chose 30 seconds) in case there are more writes to that block, or it is deleted‚Ä¢Fast and Efficient: writes return immediately, eliminates disk I/Osin many cases (e.g.many small writes to the same block)‚Ä¢Dangerous: may lose more data after a system crash!  ‚ÄúAre you willing to lose your last 30sec of work in exchange for performance bump?‚Äù‚Ä¢(Side note ‚Äìfsyncsystem call lets a program force a write to disk)Crash RecoveryWe will discuss 3 approaches to crash recovery, building up to the most common one ‚Äìlogging.Plan For Today‚Ä¢Recap and continuing: Free list and block cache‚Ä¢Crash Recovery Overview‚Ä¢Approach #1: Consistency check on reboot (fsck)‚Ä¢Approach #2: Ordered Writes‚Ä¢Approach #3: Write-Ahead Logging (‚ÄúJournaling‚Äù)Crash RecoveryIdea #1: don‚Äôt make any design changes to the filesystem structure to implement crash recovery.  Instead, let‚Äôs write a program that runs on bootup to check the filesystem for consistency and repair any problems it can.Example: Unix fsck(‚Äúfile system check‚Äù)‚Ä¢Must check whether there was a clean shutdown (if so, no work to do).  How do we know?  Set flag on disk on clean shutdown, clear flag on reboot.‚Ä¢If there wasn‚Äôt, then scan disk contents, identify inconsistencies, repair them.‚Ä¢Scans metadata (inodes, indirect blocks, free list, directories)‚Ä¢Goals: restore consistency, minimize info lossPossible fsckScenariosExample #1: block in file and alsoin free list?Action: remove block from free listExample 2: block a part of two different files (!!)(Maybe deleting a file, then making a new file, but with the block cache the new file updates were written but not the old file updates)Action: randomly pick which file should get it?  Make a copy for each?  Remove from both? (probably not, don‚Äôt want to lose potentially-useful data)Example 3: inode reference count> 0,but not referenced in any directory.Action: create link in special lost+founddirectory.Limitations of fsckWhat are the downsides/limitations of fsck?‚Ä¢Time: can‚Äôt restart system until fsckcompletes.  Larger disks mean larger recovery time (Used to be manageable, but now to read every block sequentially in a 5TB disk -> 8 hours!)‚Ä¢Restores consistency but doesn‚Äôt prevent loss of information.‚Ä¢Restores consistency but filesystem may still be unusable (e.g.a bunch of core system files moved to lost+found)‚Ä¢Security issues: a block could migrate from a password file to some other random file.
Can we do better?What if we made design changes to the filesystem structure to implement crash recovery?Plan For Today‚Ä¢Recap and continuing: Free list and block cache‚Ä¢Crash Recovery Overview‚Ä¢Approach #1: Consistency check on reboot (fsck)‚Ä¢Approach #2: Ordered Writes‚Ä¢Approach #3: Write-Ahead Logging (‚ÄúJournaling‚Äù)Ordered WritesIdea #2: what if we could make any design changes to the filesystem structure to implement crash recovery?  What could we implement?Let‚Äôs revisit a corruption example: block in file and alsoin free list. (e.g.file growing, claims block from free list, but crash before free list updates)What could we require about the order of operations here to ensure that a block is never both in the free list and in an inode?
We could require that writes happen in a particular order.  E.g.always write updates to free list before updates to inode in this example.Ordered WritesIdea #2: what if we could make any design changes to the filesystem structure to implement crash recovery?  What could we implement?We could prevent certain kinds of inconsistencies by making updates in a particular order.Example: adding block to file: first write back the free list, then write the inode.  Thuswe could never have a block in both the free list and an inode.  However, we could leak disk blocks (how?)Ordered WritesIdea #2: We could prevent certain kinds of inconsistencies by making updates in a particular order.  In some situations, force synchronous writes to ensure a particular order.In general:‚Ä¢Always initialize target before initializing new reference (e.g.initialize inodebefore adding directory entry to it)‚Ä¢Never reuse a resource (inode, disk block, etc.) before nullifying all existing references to it (e.g.adding block to free list)‚Ä¢Never clear last reference to a live resource before setting new reference, preserving data so you don‚Äôt lose it (e.g.moving a file)Result: eliminate the need to wait for fsckon reboot!Ordered WritesDownside #1:performance.  This approach forces synchronous metadata writes in the middle of operations, partially defeating the point of the block cache.Improvement: don‚Äôt actually dosynchronous writes, just keep track of dependencies in the block cache to remember what order we must do operations when we actually dothem.Example: after adding block to file, add dependency between inode block and free list block.  When it‚Äôs time to write inode to disk, make sure free list block has been written first.Tricky to get right‚Äìcircular dependencies possible! (A -> B -> C -> A)Ordered WritesDownside #2: can leak resources (e.g.free block removed from free list but never used)Improvement:run fsckin the background to reclaim leaked resources (fsckcan run in background because filesystem is repaired, but resources have leaked)
Can we do better?  E.g., can we avoid leaking data? Plan For Today‚Ä¢Recap and continuing: Free list and block cache‚Ä¢Crash Recovery Overview‚Ä¢Approach #1: Consistency check on reboot (fsck)‚Ä¢Approach #2: Ordered Writes‚Ä¢Approach #3: Write-Ahead Logging (‚ÄúJournaling‚Äù)Write-Ahead Logging (Journaling)‚Ä¢Have an append-only log on disk that stores information about disk operations‚Ä¢Before performing an operation, record its info in the log, and write that to disk beforedoing the operation itself (‚Äúwrite-ahead‚Äù)‚Ä¢E.g.‚ÄúI am adding block 4267 to inode27, index 5‚Äù‚Ä¢Then, the actual block updates can be carried out later, in any order‚Ä¢If a crash occurs, replay the log to make sure all updates are completed on disk.  Thus, we can detect/fix inconsistencies without a full disk scan.Write-Ahead Logging (Journaling)‚Ä¢Typicallywe only log metadata operations, not actual file data operations (data is much more expensive, since much more written to log).  Tradeoff!‚Ä¢Most modern filesystems do some sort of logging (e.g.Windows NTFS) ‚Äìmay allow you to choose whether you want data logging or not.‚Ä¢Logs one of the most important data structures used in systems todayassign2 Log Example[offset 33562846]* LSN 1838326418LogBlockAllocblockno: 1027zero_on_replay: 0[offset 33562862]* LSN 1838326419LogPatchblockno: 8offset_in_block: 136bytes: 0304inode#52 (i_addr[0] = block pointer 1035)Write-Ahead Logging (‚ÄúJournaling‚Äù)Problem: log entries must be written synchronously before the operationsSolution: delay writes for log, too (i.e.build log, but don‚Äôt write immediately; when a block cache block is written, write relevant log entries then).  Though this risks losing some log entries.Logging doesn‚Äôt guarantee that everything is preserved, but it does guarantee that what‚Äôs there is consistent (separates durability‚Äìdata will be preserved ‚Äìfrom consistency‚Äìstate is consistent)Write-Ahead Logging (‚ÄúJournaling‚Äù)Problem: log can get long!Solution: occasional ‚Äúcheckpoints‚Äù ‚Äìtruncate the log occasionally once we confirm that portion of the log is no longer needed.Problem: could be multiple log entries for a single ‚Äúoperation‚Äù that should happen atomically.Solution: have a log mechanism to track ‚Äútransactions‚Äù (atomic operations) and only replay those if the entire transaction is fully entered into the log. (assign2 wraps each transaction with LogBeginand LogCommit)Problem: we could replay a log operation that has already happened.Solution: make all log entries idempotent(doing multiple times has same effect as doing once).  E.g.‚Äúappend block X to file‚Äù (bad) vs. ‚Äúset block number X to Y‚ÄùCrash RecoveryWe‚Äôve discussed 3 main approaches to crash recovery:1.Consistency check on reboot (fsck) ‚Äìno filesystem changes, run program on boot to repair whatever we can.  But can‚Äôt restore everything and may take a while.2.Ordered Writes‚Äìmodify the write operations to always happen in particular orders, eliminating various kinds of inconsistencies.  But requires doing synchronous writes or tracking dependencies and can leak resources.  3.Write-Ahead Logging‚Äìlog metadata (and optionally file data) operations before doing the operations to create a paper trail we can redo in case of a crash.Crash Recovery OverviewUltimately, tradeoffs between durability, consistency and performance‚Ä¢E.g.if you want durability, you‚Äôre going to have to sacrifice performance‚Ä¢E.g.if you want highest performance, you‚Äôre going to have to give up some crash recovery capability‚Ä¢What kinds of failures are most important to recover from, and how much are you willing to trade off other benefits (e.g.performance)?Still lingering problems ‚Äìe.g.disks themselves can failRecap‚Ä¢Recap and continuing: Free list and block cache‚Ä¢Crash Recovery Overview‚Ä¢Approach #1: Consistency check on reboot (fsck)‚Ä¢Approach #2: Ordered Writes‚Ä¢Approach #3: Write-Ahead Logging (‚ÄúJournaling‚Äù)Next time: introduction to multiprocessing
Lecture 7 takeaway: There are various ways to implement crash recovery, each with tradeoffs between durability, consistency and performance.  Many filesystems today implement logging to recover metadata operations after a crash.